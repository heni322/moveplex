name: Deploy to VPS

on:
  push:
    branches: [ main, production ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    
    steps:
    - name: Deploy to VPS
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_PORT }}
        script: |
          # Stop existing containers first
          if [ -d "/var/www/ride-sharing-app" ]; then
            cd /var/www/ride-sharing-app
            sudo docker-compose down || true
          fi
          
          # Check if directory exists and handle accordingly
          if [ -d "/var/www/ride-sharing-app" ]; then
            echo "ğŸ“ Directory /var/www/ride-sharing-app exists"
            cd /var/www/ride-sharing-app
            
            # Check if it's a git repository
            if [ -d ".git" ]; then
              echo "ğŸ”„ Updating existing repository..."
              git fetch origin
              git reset --hard origin/main
              git clean -fd
            else
              echo "âš ï¸  Directory exists but is not a git repository. Backing up and cloning fresh..."
              cd /var/www/
              sudo mv ride-sharing-app ride-sharing-app.backup.$(date +%Y%m%d_%H%M%S)
              git clone https://github.com/${{ github.repository }}.git ride-sharing-app
              cd ride-sharing-app
            fi
          else
            echo "ğŸ“ Creating new directory and cloning repository..."
            sudo mkdir -p /var/www/ride-sharing-app
            sudo chown $USER:$USER /var/www/ride-sharing-app
            cd /var/www/
            git clone https://github.com/${{ github.repository }}.git ride-sharing-app
            cd ride-sharing-app
          fi
          
          # Create .env file from secrets
          cat > .env << EOF
          DATABASE_HOST=postgres
          DATABASE_PORT=5432
          DATABASE_USER=${{ secrets.DATABASE_USER }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          REDIS_HOST=redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
          JWT_ACCESS_EXPIRY=15m
          JWT_REFRESH_EXPIRY=7d
          BCRYPT_ROUNDS=12
          NODE_ENV=production
          PORT=3000
          ORS_API_KEY=${{ secrets.ORS_API_KEY }}
          EOF
          
          # Clean up Docker resources to ensure fresh build
          echo "ğŸ§¹ Cleaning up Docker resources..."
          sudo docker-compose down --rmi all --volumes --remove-orphans || true
          sudo docker system prune -f || true
          
          # Build and start services
          echo "ğŸ”¨ Building and starting services..."
          sudo docker-compose up -d --build --force-recreate
          
          # Wait for services to be ready
          echo "â³ Waiting for services to be ready..."
          sleep 60
          
          # Check service status
          echo "=== Service Status ==="
          sudo docker-compose ps
          
          # Show build logs if app failed to start
          if ! sudo docker-compose ps | grep -q "app.*Up"; then
            echo "=== App Build Logs ==="
            sudo docker-compose logs app
            exit 1
          fi
          
          # Run database migrations if available
          echo "ğŸ—ƒï¸  Running database migrations..."
          sudo docker-compose exec -T app npm run migration:run || echo "Migration command not available or failed"
          
          # Clean up unused Docker images
          sudo docker image prune -f
          
          # Show recent logs
          echo "=== Recent App Logs ==="
          sudo docker-compose logs --tail 20 app
          
          # Comprehensive health check
          echo "=== Health Check ==="
          sleep 15
          
          # Check if all containers are running
          if sudo docker-compose ps | grep -q "app.*Up"; then
            echo "âœ… App container is running"
            
            # Test app endpoint with retries
            for i in {1..5}; do
              if curl -f http://localhost:3002/health > /dev/null 2>&1; then
                echo "âœ… Application health check passed"
                break
              else
                echo "â³ Attempt $i: Application not responding yet, waiting..."
                sleep 10
              fi
            done
            
            # Final health check
            if ! curl -f http://localhost:3002/health > /dev/null 2>&1; then
              echo "âŒ Application failed final health check"
              sudo docker-compose logs --tail 50 app
              exit 1
            fi
          else
            echo "âŒ App container is not running"
            sudo docker-compose logs app
            exit 1
          fi
          
          # Check database and redis
          if sudo docker-compose ps | grep -q "postgres.*Up.*healthy"; then
            echo "âœ… PostgreSQL is healthy"
          else
            echo "âŒ PostgreSQL is not healthy"
          fi
          
          if sudo docker-compose ps | grep -q "redis.*Up.*healthy"; then
            echo "âœ… Redis is healthy"
          else
            echo "âŒ Redis is not healthy"
          fi
          
          echo "ğŸŒ Your application should be available at: http://37.59.98.144:3002"
          echo "ğŸ©º Health check: http://37.59.98.144:3002/health"
          echo "ğŸ“‹ View logs with: sudo docker-compose logs -f"